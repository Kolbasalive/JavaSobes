Зачем нужен `Iterable`? В нём реализован механизм итерирования `for-each` коллекций, для какой-нибудь своей, кастомной коллекции.

Почему `Map` не является `Collection`?
Если бы `Map` наследовал `Collection`, пришлось бы реализовывать методы вроде `add(E e)` или `Iterator<E>`, что **не отражает сути** ключ-значение.

# List
**`ArrayList`** - основан на массиве `Object[]`, по умолчанию размер 10, если не хватает места расширяется в 1.5 раза. 
+Доступ по индексу `O(1)`.
+Эффективен для частых операций вставки, чтения.
-Медленная вставка в середину `O(n)`.
-Тратит память если массив меняется редко.
-Вставка/удаление по индексу/элементу `O(n)`.

`LinkedList` - классический двусвязный список, внутри `E item; Node<E> next; Node<E> prev`. Умеет работать как стэк очередь список.
# Map
**`HashMap`** - структура хранения данных использующая в своей основе hash-таблицу(по своей сути - это обычный одномерный массив). 
Бакеты(ячейка массива) - основная единица этой таблицы.
Node<K, V> - узел ключ-значение.
Node состоит из: `int hash; K key; V value; Node<K, V> next` next - на случай коллизии индекса.
При добавлении нового элемента, вычисляется индекс массива (на основании хэш-функции по данному ключу), куда будет положен бакет.
При получении элемента, опять по ключу строится хэш и смотрится этот элемент. Если элемент совпадает(проверка по hash после equals) то выводит элемент.
Временная сложность - `O(1)`, но при большом количестве коллизий до `O(n)`.
Методы: put(K, V) получение, уделение, получение/удаление по ключу.

Замечания!
`Resize`
При достижении порога элементов в массиве (например 13, при изначальном размере 16), размер массива удваивается.
`Treeification`
При достижении порога ссылок (количество элементов `next`) в одном бакете - 8 и длинна массива больше 63 (если длинна меньше, то `resize` ), этот и только этот бакет превращается в красно-черное дерево, для оптимизации hashMap. 

`TreeMap` - отсортированная `HashMap`, построенная на красно-черном дереве.
При реализации можно передать свой собственный `Comporator<K>`.

`Comparable` - интерфейс реализует сам класс (буквально внутри этого класса), реализующий метод `compareTo`, показывает естественный порядок объектов. (возвращает: 0 - равен; отрицательное число - если меньше; положительное число - если больше) 
`Comparator` - интерфейс для реализации уже отдельного, своего, кастомного компаратора. (Возвращает тоже самое, что и `Comparable`).

`HashTable` - тоже самое что и `HashMap`, только с цепочечным методом решения коллизий. (Если в `HashMap` бакеты преобразуются в дерево, то тут он продолжает строить цепочку дальше)

Временная сложность - всегда `O(log(n))`.
# Set
`HashSet` - внутри используется обычный `HashMap`. Когда кладём элемент, он кладется на место ключа в `HashMap`-у, а само значение заполняется фиктивным, пустым объектом.

`LinkedHashSet` - наследуется от `HashSet`, но внутри используется `LinkedHashMap`. Связь строится через двусвязный список, то есть есть ссылка на предыдущий и следующий элемент.

`TreeSet` - Опять же построенная на основе `TreeMap` и может использовать свои кастомные методы сортировки `Comporator`. Как и `HashSet` кладёт значение вместо ключа, а поле значение заполняется фиктивным объектом `Object`. 
# Queue

`ArrayDequeue` - оптимальная реализация очередей. Основан на массиве. Может быть LIFO(Stack) FIFO. В отличии от `LinkedList` использует кольцевой буфер. Позволяет не сдвигать элементы, при удалении, а просто вставлять на место указателя. (указателей может быть два, на начало и на конец)