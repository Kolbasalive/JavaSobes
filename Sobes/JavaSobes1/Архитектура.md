	 Паттерны проектирования

Всего выделяют 3 паттерна (по Gang of Four – “Банда четырёх”):

**Порождающие паттерны.** Отвечают за _создание_ объектов. Они обеспечивают механизм, который позволяет создавать объекты, не указывая конкретный класс создаваемого объекта. Примеры: Singleton, Factory Method, Abstract Factory, Builder, Prototype.

*Singleton* - Обеспечивает наличие только одного экземпляра класса и предоставляет к нему глобальную точку доступа. Все **бины в Spring по умолчанию — Singleton.**
```Java
public class Singleton {
    private static Singleton instance;

    private Singleton() {} // приватный конструктор

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // ленивое создание
        }
        return instance;
    }

    public void doSomething() {
        System.out.println("Я единственный экземпляр!");
    }
}

```
*Builder* - Позволяет создавать сложные объекты пошагово, не перегружая конструктор.
```Java
public class User {
    private final String firstName;...
    
    private User(Builder builder) {
        this.firstName = builder.firstName;...
    }

    public static class Builder {
        private String firstName;...

        public Builder setFirstName(String firstName) {
            this.firstName = firstName;
            return this;
        }...

        public User build() {
            return new User(this);
        }
    }
}

User user = new User.Builder()
    .setFirstName("Иван")...
    .build();

```

*Prototype* - позволяет создавать новые объекты путём копирования существующих объектов-прототипов.

**Структурные паттерны**. _Организует_ классы и объекты. То есть, кто с  кем и как связан? Примеры: Adapter, Composite, Decorator, Facade, Proxy.
*Adapter* - Позволяет объектам с несовместимыми интерфейсами работать вместе.
*Decorator* - Добавляет поведение объекту без изменения его класса.

**Поведенческие паттерны.** Определяют _взаимодействие_ между объектами. Как объекты взаимодействуют друг с другом и распределяют обязанности между ними. Примеры: Observer, Strategy, Command, Mediator, State.
*Observer*(наблюдатель) -  при изменении состояния одного объекта все зависящие от него объекты автоматически уведомляются и обновляются.

	ООП

Парадигма программирования пришедшая на смену функционального программирования, из-за нарастающей сложности поддержки больших программ. 
4 Основные столпа ООП:
- **Инкапсуляция**
Сокрытие внутренней реализации и защита данных. Объект должен скрывать данные, предоставляя доступ только через публичные методы(геттеры/сеттеры).
- **Наследование**
Создание новых классов на основе существующих. С возможным добавлением или переиспользованием функционала в новых классах.
 - **Полиморфизм**
Возможность иметь разные формы для одной и той же сущности.
  - **Абстракция**
Выделение главного и сокрытие ненужной(в данной задачи), сложной логики.

	SOLID

**S** – **Single Responsibility Principle (Принцип единственной ответственности)**
Каждый класс или модуль может решать только одну задачу. О
*Один класс - одна задача.*
Например, вместо:
```Java
class Order {
    void calculateTotal() { ... }
    void saveToDatabase() { ... }
    void sendEmail() { ... }
}
```
можно распределить на несколько классов:
```Java
class Order {
    void calculateTotal() { ... }
}

class OrderRepository {
    void saveToDatabase(Order order) { ... }
}

class NotificationService {
    void sendEmail(Order order) { ... }
}
```

**O - Open/Closed Principle  (Принцип открытости/закрытости)**
Сущности должны быть открыты к расширениям, но закрыты к изменениям. *Расширяемость без изменений.*

**Liskov Substitution Principle (Принцип подстановки Лисков)**
Логика подкласса должна быть корректна по отношению к родительскому классу. Например прямоугольник не может быть дочерним классом по отношению к квадрату. *Больше про корректное наследование.*

**Interface Segregation Principle (Принцип разделения интерфейсов)**
Классы не должны зависеть от методов, которые не используют. Например, лучше сделать несколько маленьких интерфейсов, чем один большой. *Про малые интерфейсы.*

**Dependency Inversion Principle (Принцип инверсии зависимостей)**
Зависимости должны строится не на конкретных реализациях, а на абстракциях. *Про наследование от абстракций.*

	MVC, MVP, MVVM

Архитектурные паттерны, разделяющие логику приложения на слои.

- **MVC(Model-View-Controller)**
**Model** - данные и бизнес-логика
**View** - представление, вся визуальная часть показываемая пользователю.
**Controller** - Обработка пользовательского ввода и изменение Model/View.
+Простота и широкое применeние.
-Большая связанность View и Controller, да и Model со всеми остальными.

- **MVP(Model-View-Presenter)**
У presenter больше ответственности по сравнению с Controller. Так же тут View ничего не знает о Model, по сравнению с MVC.

- **MVVM(Model-View-ViewModel)**
Самый яркий пример - JetPack Compose. Минимальный код во View. И автоматическая синхронизация View и ViewModel.

