	 Паттерны проектирования

Всего выделяют 3 паттерна (по Gang of Four – “Банда четырёх”):

**Порождающие паттерны.** Отвечают за _создание_ объектов. Они обеспечивают механизм, который позволяет создавать объекты, не указывая конкретный класс создаваемого объекта. Примеры: Singleton, Factory Method, Abstract Factory, Builder, Prototype.

Factory Method - паттерн, который отделят создания объектов от его использования.
*Singleton* - Обеспечивает наличие только одного экземпляра класса и предоставляет к нему глобальную точку доступа. Все **бины в Spring по умолчанию — Singleton.**
```Java
public class Singleton {
    private static Singleton instance;

    private Singleton() {} // приватный конструктор

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // ленивое создание
        }
        return instance;
    }

    public void doSomething() {
        System.out.println("Я единственный экземпляр!");
    }
}

```
*Builder* - Позволяет создавать сложные объекты пошагово, не перегружая конструктор.
```Java
public class User {
    private final String firstName;...
    
    private User(Builder builder) {
        this.firstName = builder.firstName;...
    }

    public static class Builder {
        private String firstName;...

        public Builder setFirstName(String firstName) {
            this.firstName = firstName;
            return this;
        }...

        public User build() {
            return new User(this);
        }
    }
}

User user = new User.Builder()
    .setFirstName("Иван")...
    .build();

```

*Prototype* - позволяет создавать новые объекты путём копирования существующих объектов-прототипов.

**Структурные паттерны**. _Организует_ классы и объекты. То есть, кто с  кем и как связан? Примеры: Adapter, Composite, Decorator, Facade, Proxy.
*Adapter* - Позволяет объектам с несовместимыми интерфейсами работать вместе.
*Decorator* - Добавляет поведение объекту без изменения его класса.
*Proxy* - Паттерн, расширяющий функциональность объектов.

**Поведенческие паттерны.** Определяют _взаимодействие_ между объектами. Как объекты взаимодействуют друг с другом и распределяют обязанности между ними. Примеры: Observer, Strategy, Command, Mediator, State.
*Observer*(наблюдатель) -  при изменении состояния одного объекта все зависящие от него объекты автоматически уведомляются и обновляются.

	ООП

Парадигма программирования пришедшая на смену функционального программирования, из-за нарастающей сложности поддержки больших программ. 
4 Основные столпа ООП:
- **Инкапсуляция**
Сокрытие внутренней реализации и защита данных. Объект должен скрывать данные, предоставляя доступ только через публичные методы(геттеры/сеттеры).
- **Наследование**
Создание новых классов на основе существующих. С возможным добавлением или переиспользованием функционала в новых классах.
 - **Полиморфизм**
Возможность иметь разные формы для одной и той же сущности.
  - **Абстракция**
Выделение главного и сокрытие ненужной(в данной задачи), сложной логики.

	SOLID

Соблюдая эти принципы мы увеличиваем количество релизов, которые мы можем обработать/сделать
**S** – **Single Responsibility Principle (Принцип единственной ответственности)**
Каждый класс или модуль решает только одну задачу.
*Один класс - одна задача.*
Например, вместо:
```Java
class Order {
    void calculateTotal() { ... }
    void saveToDatabase() { ... }
    void sendEmail() { ... }
}
```
можно распределить на несколько классов:
```Java
class Order {
    void calculateTotal() { ... }
}

class OrderRepository {
    void saveToDatabase(Order order) { ... }
}

class NotificationService {
    void sendEmail(Order order) { ... }
}
```

**O - Open/Closed Principle  (Принцип открытости/закрытости)**
Сущности должны быть открыты к расширениям, но закрыты к изменениям. *Расширяемость без изменений.*

**Liskov Substitution Principle (Принцип подстановки Лисков)**
Логика подкласса должна быть корректна по отношению к родительскому классу. Например прямоугольник не может быть дочерним классом по отношению к квадрату. *Больше про корректное наследование.*

**Interface Segregation Principle (Принцип разделения интерфейсов)**
Классы не должны зависеть от методов, которые не используют. Например, лучше сделать несколько маленьких интерфейсов, чем один большой. *Про малые интерфейсы.*

**Dependency Inversion Principle (Принцип инверсии зависимостей)**
Зависимости должны строится не на конкретных реализациях, а на абстракциях. *Про наследование от абстракций.*

	Dispacher Servlet
	
![[Pasted image 20250715235136.png|500]]
`Dispatcher Servlet` - на основании каких-то мапингов (2), выбирает нужный контроллер (3), получает результат и возвращает респонс. Был придуман для оркестрации запросов, которые ему приходят

	Dynamic Proxi 
Это способ создать объект на "лету", который реализую заданный интерфейс, но перехватывает все вызовы его методов, чтобы обработать их по своему. Поэтому у нас нет реализации этого интерфейса, а есть только сам интерфейс и его логика обработки вызовов. Из логики поверх - это например: логирование, транзакции, безопасность, хеширование; реализация **аспектов** или просто на просто создание **заглушек** в тестах, без написание реализации интерфейса.

Пример Dynamic Proxi:
Сам `интерфейс`, который мы хотим "замокать"
```Java
public interface PaymentService {
    void pay(int amount);
}
```
Создание самого `прокси объекта`:
```Java

PaymentService service = (PaymentService) Proxy.newProxyInstance(
    PaymentService.class.getClassLoader(),
    new Class[]{PaymentService.class},
    new LoggingInvocationHandler()
);
```
 Сам `InvocationHandler`:
 ```Java
 public class LoggingInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("LOG: Вызов метода " + method.getName());
        // Здесь можно вызвать реальную реализацию, если она есть
        return null;
    }
}
```


	MVC, MVP, MVVM

Архитектурные паттерны, разделяющие логику приложения на слои.

- **MVC(Model-View-Controller)**
**Model** - данные и бизнес-логика
**View** - представление, вся визуальная часть показываемая пользователю.
**Controller** - Обработка пользовательского ввода и изменение Model/View.
+Простота и широкое применeние.
-Большая связанность View и Controller, да и Model со всеми остальными.

- **MVP(Model-View-Presenter)**
У presenter больше ответственности по сравнению с Controller. Так же тут View ничего не знает о Model, по сравнению с MVC.

- **MVVM(Model-View-ViewModel)**
Самый яркий пример - JetPack Compose. Минимальный код во View. И автоматическая синхронизация View и ViewModel.

